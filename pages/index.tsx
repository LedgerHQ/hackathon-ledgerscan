import type { NextPage } from 'next'
import Head from 'next/head'
import styles from '../styles/Home.module.css'
import React, { useState } from "react";

export const BtcLikeCoins = [
  "bch"  , "btc"  , "btc_testnet" ,
  "btg"  , "dash" , "dcr" ,
  "dgb"  , "doge" , "kmd" , 
  "ltc"  , "pivx" , "ppc" ,
  "qtum" , "via"  , "vtc" ,
  "xsn"  , "zen"  , "zec"
]

export const EthLikeCoins =
 ["bnb" , "etc" , "eth" , "eth_ropsten" , "eth_goerli" , "matic"]

export const AllCoins = [...BtcLikeCoins, ...EthLikeCoins]

export const EXPLORER_STAGING_URL: string = 
  "https://explorers.api-01.vault.ledger-stg.com/blockchain/v3"


export type SearchInput = {
  input: string, 
  coin?: string
}

export type SearchRequest = {
  coins: string[], 
  number?: number,
  hash?: string,
  address?: string
}

function coinOrDefault(search:SearchInput, defaults:string[]):string[] {
  if (search.coin && search.coin.length > 0) {
    return [search.coin]
  } else {
    return [...defaults]
  }
}

function searchInputEth(search:SearchInput):SearchRequest {
  let coins = coinOrDefault(search, EthLikeCoins)
  // Block and Tx hash is 0x + 32 bytes in hex
  if(search.input.length >= 64) {
    return {coins: coins, hash: search.input}
  } else {
    return {coins: coins, address: search.input}
  }
}

function searchInputBtc(search:SearchInput):SearchRequest {
  let coins = coinOrDefault(search, BtcLikeCoins)
  // Block hash is 32 bytes in hex
  if(search.input.length >= 64) {
    return {coins: coins, hash: search.input}
  } else {
    return {coins: coins, address: search.input}
  }
}

function searchInput(search:SearchInput):SearchRequest {

  // Is this a block height request ?
  let num = parseInt(search.input) 
  if(search.input.length < 32 && !isNaN(num) && num !== null) {
    let coins = coinOrDefault(search, AllCoins)
    return {coins: coins, number:num}
  }

  // Ox starting queries are ETH ones
  if(search.input.toLowerCase().startsWith("0x")) {
    return searchInputEth(search)
  } else {
    return searchInputBtc(search)
  }
}

async function explorerGET(path:string) {
  let url = `${EXPLORER_STAGING_URL}${path}`
  let res = await fetch(url)
  if(res.ok) {
    return {status: "ok", body: res.body}
  } else {
    return {status: "ko"}
  }
}

async function peekTxHash(coin:string, hash:string) {
  return await explorerGET(`/${coin}/transactions/${hash}`)
}

async function peekBlockHash(coin:string, hash:string) {
  return await explorerGET(`/${coin}/blocks/${hash}`)
}

async function peekHeight(coin:string, height:number) {
  return await explorerGET(`/${coin}/blocks/${height}`)
}

async function peekHash(coin:string, hash:string) {
  let tx = await peekTxHash(coin, hash)
  if(tx.status === "ko") {
    return await peekBlockHash(coin, hash)
  } else {
    return tx
  }
}

async function peekCoins(request:SearchRequest) {
  console.log(JSON.stringify(request))
  let awaits:Promise<boolean>[] = request.coins.map(coin => {
    if(request.number !== undefined) {
      return peekHeight(coin, request.number).then(it => it.status == "ok")
    }
    if(request.hash !== undefined) {
      return peekHash(coin, request.hash).then(it => it.status == "ok")
    }
    return Promise.resolve(false)
  })

  let actives:boolean[] = await Promise.all(awaits)

  let selected = request.coins.filter((_, i) => actives[i])

  console.log(request.coins)
  console.log(selected)

  return selected
}


const Home: NextPage = () => {
  const [coin, setCoin] = useState("");
  const [input, setInput] = useState("");

  const onSubmit = async (evt:any) => {
      evt.preventDefault();
      await peekCoins(searchInput({ coin, input}))
  }
  return (
    <div className={styles.container}>
      <Head>
        <title>Ledgerscan</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <div className={styles.grid}>
          <form onSubmit={onSubmit}>
            <select onChange={e => setCoin(e.target.value)}>
              { AllCoins.map((e, k) => <option key={k} value={e}>{e}</option>)}
            </select>
            <label><input type="text" name={input} onChange={e => setInput(e.target.value)}/></label>
            <input type="submit" value="Scan!"/>
          </form>
        </div>
      </main>
      
      <footer className={styles.footer}>
      </footer>
    </div>
  )
}

export default Home
